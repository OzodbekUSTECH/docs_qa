<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Field Mapper</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --card: #1e293b;
      --accent: #38bdf8;
      --accent-muted: rgba(56, 189, 248, 0.15);
      --purple: #a855f7;
      --text: #e2e8f0;
      --subtle: #94a3b8;
      --border: rgba(148, 163, 184, 0.2);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    .header {
      background: var(--card);
      border-bottom: 1px solid var(--border);
      padding: 20px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .header h1 {
      margin: 0;
      font-size: 1.5rem;
      letter-spacing: 0.03em;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .nav-button {
      padding: 8px 16px;
      background: rgba(56, 189, 248, 0.15);
      border: 1px solid rgba(56, 189, 248, 0.3);
      border-radius: 8px;
      color: var(--accent);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .nav-button:hover {
      background: rgba(56, 189, 248, 0.25);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    main {
      flex: 1;
      display: flex;
      min-height: 0;
      gap: 24px;
      padding: 24px;
    }

    /* ЛЕВАЯ ЧАСТЬ — PDF viewer */
    #viewerPanel {
      flex: 2;
      display: flex;
      flex-direction: column;
      min-width: 0;
      gap: 12px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.35);
    }

    /* Toolbar над документом */
    #pdfToolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }

    #pdfToolbar button {
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid var(--border);
      padding: 6px 12px;
      background: rgba(56, 189, 248, 0.15);
      color: var(--accent);
      font-size: 12px;
      transition: all 0.2s ease;
    }

    #pdfToolbar button:hover {
      background: rgba(56, 189, 248, 0.25);
      border-color: var(--accent);
    }

    #pageInfo {
      min-width: 80px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      color: var(--subtle);
    }

    #pageInfoInput {
      width: 50px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      color: var(--text);
      background: rgba(56, 189, 248, 0.1);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 13px;
    }

    #pageInfoInput:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.15);
    }

    #pdfViewerWrapper {
      position: relative;
      flex: 1;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #1a1f2e;
      overflow: auto;
      padding: 10px;
    }

    #pdfViewerWrapper.global-dim {
      filter: grayscale(0.4) brightness(0.8);
      cursor: crosshair;
    }

    .pdf-placeholder {
      color: var(--subtle);
      font-size: 14px;
      padding: 20px;
      text-align: center;
    }

    .page {
      position: relative;
      margin: 0 auto;
      background: white;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .page canvas {
      display: block;
    }

    /* Оверлеи, которые затемняют всё вокруг окна */
    .dim-overlay {
      position: absolute;
      background: rgba(0, 0, 0, 0.35);
      pointer-events: none;
      z-index: 4;
    }

    /* Прямоугольник выделения */
    .selection-box {
      position: absolute;
      border: 2px solid #ff4b4b;
      background: rgba(80, 160, 255, 0.25);
      pointer-events: auto;
      z-index: 5;
    }

    .selection-box.editing {
      background: transparent;
    }

    .selection-box.active {
      border-style: solid;
    }

    .selection-box.hover-highlight {
      border-color: #38bdf8;
      background: rgba(56, 189, 248, 0.35);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.3);
      z-index: 7;
    }

    tr.field-row.hover-highlight {
      background: rgba(56, 189, 248, 0.25);
      border-left: 3px solid var(--accent);
    }

    /* 4 хэндла по углам */
    .selection-box .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #ffffff;
      border: 2px solid #ff4b4b;
      border-radius: 50%;
      pointer-events: auto;
      z-index: 6;
    }

    .resize-nw {
      left: -7px;
      top: -7px;
      cursor: nwse-resize;
    }

    .resize-ne {
      right: -7px;
      top: -7px;
      cursor: nesw-resize;
    }

    .resize-sw {
      left: -7px;
      bottom: -7px;
      cursor: nesw-resize;
    }

    .resize-se {
      right: -7px;
      bottom: -7px;
      cursor: nwse-resize;
    }

    .selection-box.handles-hidden .resize-handle {
      display: none;
    }

    .selection-box.hidden {
      display: none;
    }

    /* Confirmation buttons for selection editing */
    .selection-confirm-buttons {
      position: absolute;
      top: -22px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      z-index: 100;
      background: var(--card);
      padding: 3px;
      border-radius: 5px;
      border: 1px solid var(--border);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
    }

    .selection-confirm-buttons button {
      width: 20px;
      height: 20px;
      padding: 0;
      font-size: 12px;
      border-radius: 3px;
      cursor: pointer;
      border: none;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
      position: relative;
      z-index: 101;
    }

    .selection-confirm-buttons .btn-confirm {
      background: var(--success);
      color: white;
    }

    .selection-confirm-buttons .btn-confirm:hover {
      background: #059669;
      transform: scale(1.1);
    }

    .selection-confirm-buttons .btn-cancel {
      background: var(--error);
      color: white;
    }

    .selection-confirm-buttons .btn-cancel:hover {
      background: #dc2626;
      transform: scale(1.1);
    }

    .selection-confirm-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Processing overlay */
    .selection-processing {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text);
      padding: 12px 20px;
      border-radius: 8px;
      border: 2px solid var(--accent);
      z-index: 11;
      font-size: 13px;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .selection-processing::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {

      0%,
      20% {
        content: '.';
      }

      40% {
        content: '..';
      }

      60%,
      100% {
        content: '...';
      }
    }

    /* ПРАВАЯ ЧАСТЬ — поля */
    #fieldsPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 0;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.35);
    }

    #fieldsPanel h2 {
      font-size: 1.1rem;
      margin: 0 0 12px;
    }

    button {
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid var(--border);
      padding: 8px 16px;
      background: rgba(56, 189, 248, 0.15);
      color: var(--accent);
      font-size: 13px;
      transition: all 0.2s ease;
    }

    button:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.25);
      border-color: var(--accent);
    }

    button.primary {
      background: linear-gradient(135deg, var(--success), #059669);
      color: white;
      border-color: var(--success);
    }

    button.primary:hover {
      background: linear-gradient(135deg, #059669, #047857);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th,
    td {
      border: 1px solid var(--border);
      padding: 8px 12px;
      vertical-align: top;
    }

    th {
      background: rgba(56, 189, 248, 0.1);
      text-align: left;
      color: var(--accent);
    }

    tr.field-row {
      cursor: pointer;
      transition: background 0.2s ease;
    }

    tr.field-row:hover {
      background: rgba(56, 189, 248, 0.1);
    }

    tr.field-row.active {
      background: rgba(56, 189, 248, 0.2);
    }

    .small {
      font-size: 12px;
      color: var(--subtle);
    }

    .field-value-input {
      width: 100%;
      min-height: 80px;
      max-height: 400px;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      font-size: 13px;
      line-height: 1.6;
      resize: vertical;
      background: rgba(15, 23, 42, 0.6);
      color: var(--text);
      transition: all 0.2s ease;
    }

    .field-value-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(15, 23, 42, 0.8);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
    }

    .field-value-input:hover {
      border-color: rgba(56, 189, 248, 0.4);
    }

    .field-value-container {
      position: relative;
      width: 100%;
    }

    .field-value-markdown {
      color: var(--text);
      line-height: 1.6;
    }

    .field-value-markdown table {
      width: auto !important;
      min-width: auto !important;
      max-width: none !important;
      border-collapse: collapse;
      background: rgba(15, 23, 42, 0.5);
      border-radius: 8px;
      overflow: visible;
      border: 1px solid var(--border);
      margin: 12px 0;
      font-size: 13px;
      table-layout: auto !important;
      display: table !important;
    }
    
    /* Specific styles for tables in modal view mode */
    #tableModal .field-value-markdown table {
      width: auto !important;
      min-width: auto !important;
      max-width: none !important;
      table-layout: auto !important;
    }
    
    #tableModal .field-value-markdown th,
    #tableModal .field-value-markdown td {
      width: auto !important;
      min-width: auto !important;
      max-width: none !important;
      white-space: nowrap !important;
    }

    .field-value-markdown th {
      padding: 10px 12px;
      text-align: left;
      border: 1px solid var(--border);
      border-bottom: 2px solid var(--border);
      background: rgba(56, 189, 248, 0.15);
      color: var(--accent);
      font-weight: 600;
      white-space: nowrap !important;
      width: auto !important;
      min-width: auto !important;
      max-width: none !important;
    }

    .field-value-markdown td {
      padding: 8px 12px;
      border: 1px solid rgba(56, 189, 248, 0.1);
      border-bottom: 1px solid var(--border);
      white-space: nowrap !important;
      width: auto !important;
      min-width: auto !important;
      max-width: none !important;
    }

    .field-value-markdown tr:last-child td {
      border-bottom: 1px solid var(--border);
    }
    
    .field-value-markdown tr:hover {
      background: rgba(56, 189, 248, 0.05);
    }
    
    .table-editor table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(15, 23, 42, 0.3);
      font-size: 13px;
    }
    
    .table-editor th input,
    .table-editor td input {
      transition: all 0.2s ease;
    }
    
    .table-editor th input:focus,
    .table-editor td input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.1);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
    }

    .field-value-markdown p {
      margin: 8px 0;
    }

    .field-value-markdown code {
      background: rgba(56, 189, 248, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .field-value-markdown pre {
      background: rgba(15, 23, 42, 0.5);
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      border: 1px solid var(--border);
    }

    .field-value-markdown pre code {
      background: transparent;
      padding: 0;
    }

    .field-value-markdown ul,
    .field-value-markdown ol {
      margin: 8px 0;
      padding-left: 24px;
    }

    .field-value-markdown li {
      margin: 4px 0;
    }

    .field-value-markdown h1,
    .field-value-markdown h2,
    .field-value-markdown h3,
    .field-value-markdown h4,
    .field-value-markdown h5,
    .field-value-markdown h6 {
      margin: 16px 0 8px;
      color: var(--accent);
    }

    .panel-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .panel-header h2 {
      margin: 0;
      flex: 1;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
    }

    .checkbox-label input[type="checkbox"] {
      cursor: pointer;
    }
  </style>
</head>

<body>
  <header class="header">
    <div class="header-left">
      <a href="/" class="nav-button">← Back</a>
      <h1>Document Field Mapper</h1>
    </div>
    <div style="display: flex; gap: 12px; align-items: center;">
      <span id="documentName" class="small"></span>
      <button id="saveBtn" class="primary">Save</button>
      <button id="closeBtn">Close</button>
    </div>
  </header>
  <main>
    <!-- ЛЕВАЯ ПАНЕЛЬ -->
    <section id="viewerPanel">
      <div id="pdfToolbar">
        <button id="prevPageBtn">‹</button>
        <span id="pageInfo">
          <input type="number" id="pageInfoInput" min="1" value="0" style="display: none;">
          <span id="pageInfoText">0 / 0</span>
        </span>
        <button id="nextPageBtn">›</button>
        <span style="margin-left: 12px; color: var(--subtle);">Zoom:</span>
        <button id="zoomOutBtn">-</button>
        <button id="zoomInBtn">+</button>
      </div>
      <div id="pdfViewerWrapper">
        <div class="pdf-placeholder">
          Loading document...
        </div>
      </div>
    </section>
    <!-- ПРАВАЯ ПАНЕЛЬ -->
    <section id="fieldsPanel">
      <div class="panel-header">
        <h2>Fields</h2>
        <button id="addFieldBtn">Add field</button>
        <label class="checkbox-label small" style="display: none;">
          <input type="checkbox" id="viewAllFields" checked />
          View all pages
        </label>
      </div>
      <span class="small">
        • Click "Add field" to create a new field.<br />
        • Click on a field row to select/edit its region.<br />
        • All fields are shown on all pages, but values are only displayed for the current page.
      </span>
      <table>
        <thead>
          <tr>
            <th style="width: 25%;">Field</th>
            <th>Value / Coords</th>
            <th style="width: 80px;">Actions</th>
          </tr>
        </thead>
        <tbody id="fieldsTableBody"></tbody>
      </table>
    </section>
  </main>

  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <!-- marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // pdf.js worker
    window.pdfjsLib = window["pdfjsLib"];
    if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    }

    // Get document ID from URL
    const urlParams = new URLSearchParams(window.location.search);
    const documentId = urlParams.get('id');
    if (!documentId) {
      document.getElementById('pdfViewerWrapper').innerHTML = '<div class="pdf-placeholder">Error: No document ID provided</div>';
    }

    const pdfViewerWrapper = document.getElementById("pdfViewerWrapper");
    const addFieldBtn = document.getElementById("addFieldBtn");
    const fieldsTableBody = document.getElementById("fieldsTableBody");
    const prevPageBtn = document.getElementById("prevPageBtn");
    const nextPageBtn = document.getElementById("nextPageBtn");
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const pageInfo = document.getElementById("pageInfo");
    const pageInfoInput = document.getElementById("pageInfoInput");
    const pageInfoText = document.getElementById("pageInfoText");
    const viewAllFieldsCheckbox = document.getElementById("viewAllFields");
    const saveBtn = document.getElementById("saveBtn");
    const closeBtn = document.getElementById("closeBtn");
    const documentNameEl = document.getElementById("documentName");

    // поле: { id?, field_id?, custom_field_name?, name, value, region?: { page, x1, y1, x2, y2 } }
    let fields = [];
    let activeFieldIndex = null;
    let selectionMode = false;
    let createMode = false;
    let editMode = false;
    let isDragging = false;
    let dragType = null;
    let dragStartX = 0;
    let dragStartY = 0;
    let startLeft = 0;
    let startTop = 0;
    let startWidth = 0;
    let startHeight = 0;
    let currentPageDiv = null;
    let currentPageCanvas = null;
    let currentPageIndex = null;
    let currentSelectionBox = null;
    let pdfDoc = null;
    let currentPageNum = 1;
    let totalPages = 0;
    let scale = 1.3;
    let documentData = null;
    let originalRegion = null; // Store original region coordinates for cancel
    let confirmButtonsContainer = null; // Container for confirm/cancel buttons
    let isProcessing = false; // Track if OCR is in progress

    // Normalize file URL (same as in index.html)
    function normalizeFileUrl(filePath) {
      if (!filePath) return null;
      let url = filePath.replace(/\\/g, '/').trim();

      // Remove 'storage/' prefix if present (Windows paths)
      if (url.startsWith('storage/')) {
        url = url.substring(8);
      }

      // If already starts with /storage/, use as is
      if (url.startsWith('/storage/')) {
        return url;
      }

      // If starts with http, use as is
      if (url.startsWith('http')) {
        return url;
      }

      // If starts with /, add /storage prefix
      if (url.startsWith('/')) {
        return `/storage${url}`;
      }

      // Otherwise, add /storage/ prefix
      return `/storage/${url}`;
    }

    // Load document and fields
    async function loadDocument() {
      try {
        const response = await fetch(`/documents/${documentId}`);
        documentData = await response.json();
        documentNameEl.textContent = documentData.filename || `Document #${documentId}`;

        // Load PDF with normalized URL
        const pdfUrl = normalizeFileUrl(documentData.file_path);
        if (!pdfUrl) {
          throw new Error('Invalid file path');
        }

        pdfDoc = await window.pdfjsLib.getDocument(pdfUrl).promise;
        totalPages = pdfDoc.numPages;
        updatePageInfo();

        // Load fields
        await loadFields();

        // Check if page parameter is provided in URL
        const initialPage = urlParams.get('page');
        const pageNum = initialPage ? parseInt(initialPage) : 1;

        // Render specified page or first page
        await renderPage(Math.min(Math.max(pageNum, 1), totalPages));
      } catch (error) {
        console.error('Error loading document:', error);
        pdfViewerWrapper.innerHTML = '<div class="pdf-placeholder">Error loading document: ' + error.message + '</div>';
      }
    }

    async function loadFields() {
      try {
        const response = await fetch(`/documents/${documentId}/fields`);
        const fieldsData = await response.json();

        // Group fields by name/identifier to handle multiple occurrences
        // One field can appear on multiple pages - group them together
        const fieldsMap = new Map();
        
        fieldsData.forEach(f => {
          // Create unique key: use field_id if exists, otherwise use custom_field_name
          // If both are null, use field_name as fallback
          const key = f.field_id 
            ? `field_${f.field_id}` 
            : (f.custom_field_name 
              ? `custom_${f.custom_field_name}` 
              : `name_${f.field_name}`);
          const name = f.field_name;
          
          if (!fieldsMap.has(key)) {
            fieldsMap.set(key, {
              id: f.id, // Keep first id for reference
              field_id: f.field_id,
              custom_field_name: f.custom_field_name,
              name: name,
              occurrences: [] // Store all occurrences (one per page)
            });
          }
          
          // Add this occurrence (one per page)
          // Only add if it has valid data (value or region)
          if (f.value || (f.bbox && f.page_number)) {
            fieldsMap.get(key).occurrences.push({
              id: f.id,
              value: f.value || null,
              region: f.bbox && f.page_number ? {
                page: f.page_number,
                x1: f.bbox[0],
                y1: f.bbox[1],
                x2: f.bbox[2],
                y2: f.bbox[3]
              } : null,
              page_number: f.page_number
            });
          }
        });
        
        // Convert to flat array - one field entry per field name
        // Each field has multiple occurrences stored in _occurrences
        // Show ALL fields even if they have no occurrences yet
        const newFields = [];
        fieldsMap.forEach((fieldGroup, key) => {
          // Add field even if it has no occurrences (for UI consistency)
          newFields.push({
            id: fieldGroup.id,
            field_id: fieldGroup.field_id,
            custom_field_name: fieldGroup.custom_field_name,
            name: fieldGroup.name,
            value: null, // Will be set based on current page
            region: null, // Will be set based on current page
            _occurrences: fieldGroup.occurrences // Store all occurrences (can be empty)
          });
          if (fieldGroup.occurrences.length > 0) {
            console.log(`[loadFields] Added field '${fieldGroup.name}' with ${fieldGroup.occurrences.length} occurrences on pages:`, 
              fieldGroup.occurrences.map(o => o.page_number).filter(p => p));
          } else {
            console.log(`[loadFields] Added field '${fieldGroup.name}' with no occurrences yet`);
          }
        });

        // Update fields array atomically to avoid race conditions
        fields = newFields;
        console.log(`[loadFields] Total fields loaded: ${fields.length}`);
        
        // Always render fields after loading
        renderFields();
      } catch (error) {
        console.error('Error loading fields:', error);
      }
    }

    function updatePageInfo() {
      const displayText = `${totalPages ? currentPageNum : 0} / ${totalPages}`;
      pageInfoText.textContent = displayText;
      if (pageInfoInput) {
        pageInfoInput.value = currentPageNum || 1;
        pageInfoInput.max = totalPages || 1;
      }
    }

    // Make page info editable
    pageInfoText.addEventListener("click", () => {
      if (!pdfDoc || !totalPages) return;
      pageInfoText.style.display = "none";
      pageInfoInput.style.display = "inline-block";
      pageInfoInput.value = currentPageNum;
      pageInfoInput.focus();
      pageInfoInput.select();
    });

    pageInfoInput.addEventListener("blur", () => {
      const pageNum = parseInt(pageInfoInput.value);
      if (pageNum >= 1 && pageNum <= totalPages) {
        renderPage(pageNum);
      } else {
        updatePageInfo();
      }
      pageInfoInput.style.display = "none";
      pageInfoText.style.display = "inline";
    });

    pageInfoInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        pageInfoInput.blur();
      } else if (e.key === "Escape") {
        e.preventDefault();
        updatePageInfo();
        pageInfoInput.style.display = "none";
        pageInfoText.style.display = "inline";
      }
    });

    async function renderPage(pageNum) {
      if (!pdfDoc) return;
      resetSelectionState(false);
      clearAllOverlays();
      pdfViewerWrapper.classList.remove("global-dim");
      pdfViewerWrapper.innerHTML = "";
      currentPageNum = pageNum;
      
      console.log(`[renderPage] Rendering page ${pageNum}, fields count: ${fields.length}`);

      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });
      const pageDiv = document.createElement("div");
      pageDiv.className = "page";
      pageDiv.dataset.pageIndex = String(pageNum);
      pageDiv.style.width = viewport.width + "px";
      pageDiv.style.height = viewport.height + "px";

      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      pageDiv.appendChild(canvas);
      pdfViewerWrapper.appendChild(pageDiv);

      await page.render({ canvasContext: context, viewport }).promise;
      currentPageDiv = pageDiv;
      currentPageCanvas = canvas;
      currentPageIndex = pageNum;
      setupPageSelection(pageDiv);

      // Render all boxes for fields on this page
      fields.forEach((field, idx) => {
        // Check if field has occurrence on this page
        let regionToRender = null;
        if (field._occurrences && field._occurrences.length > 0) {
          const occ = field._occurrences.find(o => o.region && o.region.page === pageNum);
          if (occ) {
            regionToRender = occ.region;
          }
        } else if (field.region && field.region.page === pageNum) {
          regionToRender = field.region;
        }
        
        if (regionToRender) {
          const r = regionToRender;
          const left = r.x1 * canvas.width;
          const top = r.y1 * canvas.height;
          const width = (r.x2 - r.x1) * canvas.width;
          const height = (r.y2 - r.y1) * canvas.height;
          const box = createSelectionBox(left, top, width, height, idx, pageNum);
          pageDiv.appendChild(box);
        }
      });

      updatePageInfo();
      activeFieldIndex = null;
      
      // Ensure fields are loaded before rendering
      if (fields.length === 0) {
        console.warn(`[renderPage] Fields array is empty on page ${pageNum}, reloading...`);
        await loadFields();
      }
      
      renderFields();
    }

    // Event handlers
    prevPageBtn.addEventListener("click", () => {
      if (!pdfDoc) return;
      if (currentPageNum > 1) {
        renderPage(currentPageNum - 1);
      }
    });

    nextPageBtn.addEventListener("click", () => {
      if (!pdfDoc) return;
      if (currentPageNum < totalPages) {
        renderPage(currentPageNum + 1);
      }
    });

    zoomInBtn.addEventListener("click", () => {
      if (!pdfDoc) return;
      scale = Math.min(scale * 1.2, 3.0);
      renderPage(currentPageNum);
    });

    zoomOutBtn.addEventListener("click", () => {
      if (!pdfDoc) return;
      scale = Math.max(scale / 1.2, 0.5);
      renderPage(currentPageNum);
    });

    viewAllFieldsCheckbox.addEventListener("change", () => {
      renderFields();
    });

    // Modal for adding field
    const addFieldModal = document.createElement("div");
    addFieldModal.id = "addFieldModal";
    addFieldModal.style.cssText = `
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    `;
    addFieldModal.innerHTML = `
      <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 500px; width: 90%; border: 1px solid var(--border);">
        <h3 style="margin: 0 0 20px; font-size: 1.2rem;">Add Custom Field</h3>
        <div style="display: flex; flex-direction: column; gap: 16px;">
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary);">Field Name</label>
            <input type="text" id="fieldNameInput" placeholder="e.g., AKH ref" style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">Identifier: <span id="fieldIdentifierPreview" style="color: var(--accent);"></span></div>
          </div>
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary);">Extraction By</label>
            <select id="extractionByInput" style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
              <option value="DOCUMENT_AI">Document AI (Custom Extractor)</option>
              <option value="GEMINI_AI" selected>Gemini AI (Generative)</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary);">Field Type</label>
            <select id="fieldTypeInput" style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
              <option value="TEXT">Text</option>
              <option value="CLAUSE">Clause</option>
              <option value="DATE">Date</option>
              <option value="NUMBER">Number</option>
              <option value="BOOL">Boolean</option>
              <option value="TABLE">Table</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary);">Occurrence (DocAI only)</label>
            <select id="fieldOccurrenceInput" style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px;">
              <option value="OPTIONAL_ONCE">Optional Once</option>
              <option value="REQUIRED_ONCE">Required Once</option>
              <option value="OPTIONAL_MULTIPLE">Optional Multiple</option>
              <option value="REQUIRED_MULTIPLE">Required Multiple</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary);">Prompt / Description</label>
            <textarea id="fieldDescriptionInput" placeholder="Describe what to extract (or prompt for Gemini)" style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 14px; min-height: 80px; resize: vertical;"></textarea>
          </div>
          <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px;">
            <button id="cancelAddFieldBtn" style="padding: 8px 16px; background: transparent; border: 1px solid var(--border); color: var(--text);">Cancel</button>
            <button id="confirmAddFieldBtn" style="padding: 8px 16px; background: var(--accent); color: white; border: none;">Add Field</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(addFieldModal);

    // Convert name to identifier (AKH ref -> akh_ref)
    function nameToIdentifier(name) {
      return name
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
    }

    const fieldNameInput = document.getElementById("fieldNameInput");
    const fieldIdentifierPreview = document.getElementById("fieldIdentifierPreview");
    const fieldDescriptionInput = document.getElementById("fieldDescriptionInput");
    const fieldOccurrenceInput = document.getElementById("fieldOccurrenceInput");
    const extractionByInput = document.getElementById("extractionByInput");
    const fieldTypeInput = document.getElementById("fieldTypeInput");
    const cancelAddFieldBtn = document.getElementById("cancelAddFieldBtn");
    const confirmAddFieldBtn = document.getElementById("confirmAddFieldBtn");

    fieldNameInput.addEventListener("input", () => {
      const identifier = nameToIdentifier(fieldNameInput.value);
      fieldIdentifierPreview.textContent = identifier || "(will be generated)";
    });

    cancelAddFieldBtn.addEventListener("click", () => {
      addFieldModal.style.display = "none";
      fieldNameInput.value = "";
      fieldDescriptionInput.value = "";
      fieldOccurrenceInput.value = "OPTIONAL_ONCE";
      extractionByInput.value = "GEMINI_AI";
      fieldTypeInput.value = "TEXT";
    });

    addFieldBtn.addEventListener("click", () => {
      addFieldModal.style.display = "flex";
      fieldNameInput.focus();
      fieldIdentifierPreview.textContent = "";
      extractionByInput.value = "GEMINI_AI"; // Set default to Gemini AI
    });

    confirmAddFieldBtn.addEventListener("click", async () => {
      const name = fieldNameInput.value.trim();
      if (!name) {
        alert("Please enter a field name");
        return;
      }

      const identifier = nameToIdentifier(name);
      const description = fieldDescriptionInput.value.trim();
      const occurrence = fieldOccurrenceInput.value;
      const extractionBy = extractionByInput.value;
      const type = fieldTypeInput.value;

      // Close modal
      addFieldModal.style.display = "none";

      // Add field temporarily (will be replaced after extraction)
      const fieldIndex = fields.length;
      fields.push({
        name: name,
        custom_field_name: identifier,
        value: null, // Empty initially
        region: null,
        _processing: true, // Always processing initially for AI
        _occurrences: [] // Will be populated after extraction
      });
      renderFields();

      // Use AI extraction (always true now as we use either DocAI or Gemini)
      fields[fieldIndex].value = "processing...";
      renderFields();

      try {
        // Call extractor
        const formData = new FormData();
        formData.append('custom_field_name', identifier);
        formData.append('description', description || `Extract ${name} from document`);
        formData.append('occurrence', occurrence);
        // For Gemini AI, don't send page_number - it searches all pages
        // For Document AI, send current page for filtering
        if (extractionBy !== 'GEMINI_AI') {
          formData.append('page_number', currentPageNum);
        }
        formData.append('extraction_by', extractionBy);
        formData.append('type', type);
        formData.append('prompt', description); // Use description as prompt

        const response = await fetch(`/documents/${documentId}/extract-field`, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        // Update field with result
        const field = fields[fieldIndex];
        field._processing = false;

        if (result.found && result.value) {
          // Reload all fields from server to get all occurrences
          // This ensures we have all pages' values
          await loadFields();
          // Don't navigate - stay on current page
        } else {
          field.value = null; // Will show as "----"
        }

        renderFields();
      } catch (error) {
        console.error('Error extracting field:', error);
        const field = fields[fieldIndex];
        field._processing = false;
        field.value = null; // Will show as "----"
        renderFields();
      }
    });

    saveBtn.addEventListener("click", async () => {
      try {
        // Collect all occurrences from all fields
        const fieldValues = [];
        fields.forEach(f => {
          // Skip processing fields
          if (f._processing) return;
          
          if (f._occurrences && f._occurrences.length > 0) {
            // Save all occurrences
            f._occurrences.forEach(occ => {
              if (occ.value && occ.value !== "----" && occ.value !== null && occ.value.trim() && occ.region) {
                fieldValues.push({
                  id: occ.id || null,
                  field_id: f.field_id || null,
                  custom_field_name: f.custom_field_name || (f.field_id ? null : f.name),
                  value: occ.value,
                  confidence: 1.0,
                  bbox: occ.region ? [occ.region.x1, occ.region.y1, occ.region.x2, occ.region.y2] : null,
                  page_number: occ.region ? occ.region.page : null
                });
              }
            });
          } else {
            // Backward compatibility - single occurrence
            const val = f.value;
            if (val && val !== "----" && val !== null && val.trim() && f.region) {
              fieldValues.push({
                id: f.id || null,
                field_id: f.field_id || null,
                custom_field_name: f.custom_field_name || (f.field_id ? null : f.name),
                value: f.value,
                confidence: 1.0,
                bbox: f.region ? [f.region.x1, f.region.y1, f.region.x2, f.region.y2] : null,
                page_number: f.region ? f.region.page : null
              });
            }
          }
        });

        const formData = new FormData();
        formData.append('field_values', JSON.stringify(fieldValues));

        const response = await fetch(`/documents/${documentId}/save-field-values`, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();
        if (result.success) {
          alert('Saved successfully!');
          await loadFields();
        } else {
          alert('Error saving: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        alert('Error saving: ' + error.message);
      }
    });

    closeBtn.addEventListener("click", () => {
      window.location.href = '/';
    });

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // Configure marked.js for markdown rendering
    if (typeof marked !== 'undefined') {
      marked.setOptions({
        breaks: true,
        gfm: true,
        tables: true
      });
    }

    function renderFields() {
      fieldsTableBody.innerHTML = "";
      
      // Show ALL fields for the document ALWAYS (never filter them out)
      // Value will be shown only if there's an occurrence on current page
      console.log(`[renderFields] Rendering ${fields.length} fields on page ${currentPageNum}`);
      
      if (fields.length === 0) {
        console.warn(`[renderFields] WARNING: fields array is empty! This should not happen.`);
        // Try to reload fields if empty
        loadFields().then(() => {
          console.log(`[renderFields] Reloaded fields, now have ${fields.length} fields`);
          renderFields(); // Re-render after reload
        });
        return;
      }

      fields.forEach((field, index) => {
        const tr = document.createElement("tr");
        tr.className = "field-row" + (index === activeFieldIndex ? " active" : "");
        tr.dataset.fieldIndex = index;

        const tdName = document.createElement("td");
        const tdValue = document.createElement("td");

        tdName.textContent = field.name;
        
        // Find occurrence for current page (if field has multiple occurrences)
        let fieldValueToShow = null;
        let fieldRegionToShow = null;
        let shouldShowValue = false;
        
        let isProcessingOccurrence = false;
        
        if (field._occurrences && field._occurrences.length > 0) {
          // Find occurrence for current page
          const currentPageOccurrence = field._occurrences.find(occ => 
            occ.region && occ.region.page === currentPageNum
          );
          
          if (currentPageOccurrence) {
            fieldValueToShow = currentPageOccurrence.value;
            fieldRegionToShow = currentPageOccurrence.region;
            isProcessingOccurrence = currentPageOccurrence._processing === true;
            shouldShowValue = true;
          } else {
            // Should not happen as we filtered above, but just in case
            shouldShowValue = false;
          }
        } else {
          // No occurrences stored - use field.value and field.region (backward compatibility)
          fieldValueToShow = field.value;
          fieldRegionToShow = field.region;
          isProcessingOccurrence = field._processing === true;
          shouldShowValue = !field.region || field.region.page === currentPageNum;
        }

        // Add hover effects to link field row with selection box
        tr.addEventListener("mouseenter", () => {
          if (fieldRegionToShow) {
            tr.classList.add("hover-highlight");
            // Highlight corresponding box on document
            const boxes = document.querySelectorAll(`.selection-box[data-field-index="${index}"]`);
            boxes.forEach(box => {
              box.classList.add("hover-highlight");
            });
          }
        });

        tr.addEventListener("mouseleave", () => {
          tr.classList.remove("hover-highlight");
          // Remove highlight from boxes
          const boxes = document.querySelectorAll(`.selection-box[data-field-index="${index}"]`);
          boxes.forEach(box => {
            box.classList.remove("hover-highlight");
          });
        });

        // Display field value (use fieldValueToShow if multiple occurrences)
        // Value is shown ONLY if there's an occurrence on current page
        const fieldValue = shouldShowValue ? (fieldValueToShow || "") : "";
        
        if (!shouldShowValue) {
          // Field exists but no value on current page - show placeholder
          const placeholder = document.createElement("div");
          placeholder.textContent = "----";
          placeholder.style.color = "var(--subtle)";
          placeholder.style.opacity = "0.5";
          placeholder.style.padding = "8px";
          placeholder.title = field._occurrences && field._occurrences.length > 0 
            ? `Field exists on pages: ${field._occurrences.map(o => o.page_number).filter(p => p).join(", ")}`
            : "No value on this page";
          tdValue.appendChild(placeholder);
        } else if (isProcessingOccurrence) {
          // Show processing state for this specific occurrence
          const processing = document.createElement("div");
          processing.textContent = "processing...";
          processing.style.color = "var(--subtle)";
          processing.style.opacity = "0.6";
          processing.style.fontStyle = "italic";
          processing.style.padding = "8px";
          tdValue.appendChild(processing);
        } else if (!fieldValueToShow || fieldValueToShow === null || fieldValueToShow === "processing...") {
          // Show empty state
          const empty = document.createElement("div");
          empty.textContent = "----";
          empty.style.color = "var(--subtle)";
          empty.style.padding = "8px";
          tdValue.appendChild(empty);
        } else {
          // Display markdown content
          const valueContainer = document.createElement("div");
          valueContainer.className = "field-value-container";
          valueContainer.setAttribute("data-field-index", index);
          valueContainer.style.position = "relative";
          
          // Store editing state
          let isEditing = false;
          
          // Helper function to check if value is a markdown table
          function isMarkdownTable(text) {
            if (!text || typeof text !== 'string') return false;
            const lines = text.trim().split('\n');
            if (lines.length < 2) return false;
            // Check if first line starts with |
            if (!lines[0].trim().startsWith('|')) return false;
            // Check if there's a separator line (|---| or similar)
            const hasSeparator = lines.some(line => 
              line.trim().match(/^\|[\s\-:|]+\|$/)
            );
            // Check if multiple lines start with |
            const tableRows = lines.filter(line => line.trim().startsWith('|')).length;
            return hasSeparator || tableRows >= 2;
          }
          
          // Helper function to parse markdown table to array
          function parseMarkdownTable(markdown) {
            const lines = markdown.trim().split('\n').filter(l => l.trim());
            const rows = [];
            for (const line of lines) {
              const trimmed = line.trim();
              if (trimmed.match(/^\|[\s\-:|]+\|$/)) continue; // Skip separator
              if (!trimmed.startsWith('|')) continue;
              const cells = trimmed.slice(1, -1).split('|').map(c => c.trim());
              rows.push(cells);
            }
            return rows;
          }
          
          // Helper function to convert table array to markdown
          function tableToMarkdown(table) {
            if (!table || table.length === 0) return '';
            const rows = table.map(row => '| ' + row.join(' | ') + ' |');
            if (rows.length > 0) {
              const colCount = table[0].length;
              const separator = '| ' + Array(colCount).fill('---').join(' | ') + ' |';
              return rows[0] + '\n' + separator + '\n' + rows.slice(1).join('\n');
            }
            return rows.join('\n');
          }
          
          function renderValue() {
            const valueToRender = fieldValueToShow || field.value || "";
            const isTable = isMarkdownTable(valueToRender);
            
            if (isEditing) {
              if (isTable) {
                // Render editable table
                const tableData = parseMarkdownTable(valueToRender);
                const tableEditor = document.createElement("div");
                tableEditor.className = "table-editor";
                tableEditor.style.cssText = "overflow-x: auto; max-width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.5); border-radius: 8px; border: 1px solid var(--border);";
                
                // Prevent table editor events from triggering document selection
                tableEditor.addEventListener("mousedown", (e) => e.stopPropagation());
                tableEditor.addEventListener("mouseup", (e) => e.stopPropagation());
                tableEditor.addEventListener("mousemove", (e) => e.stopPropagation());
                tableEditor.addEventListener("click", (e) => e.stopPropagation());
                
                const table = document.createElement("table");
                table.style.cssText = "width: 100%; border-collapse: collapse; background: rgba(15, 23, 42, 0.3);";
                
                // Render header row
                if (tableData.length > 0) {
                  const headerRow = document.createElement("tr");
                  tableData[0].forEach((cell, idx) => {
                    const th = document.createElement("th");
                    th.style.cssText = "padding: 8px; border: 1px solid var(--border); background: rgba(56, 189, 248, 0.15); text-align: left; min-width: 80px;";
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = cell || "";
                    input.style.cssText = "width: 100%; padding: 4px 8px; background: transparent; border: none; color: var(--text); font-weight: 600; font-size: 13px; box-sizing: border-box;";
                    input.addEventListener("mousedown", (e) => e.stopPropagation());
                    input.addEventListener("click", (e) => e.stopPropagation());
                    input.oninput = () => {
                      tableData[0][idx] = input.value;
                      updateFieldValue();
                    };
                    th.appendChild(input);
                    headerRow.appendChild(th);
                  });
                  table.appendChild(headerRow);
                }
                
                // Render body rows
                for (let i = 1; i < tableData.length; i++) {
                  const tr = document.createElement("tr");
                  // Ensure row has same number of cells as header
                  const expectedCols = tableData[0] ? tableData[0].length : 0;
                  const rowCells = tableData[i] || [];
                  for (let idx = 0; idx < Math.max(expectedCols, rowCells.length); idx++) {
                    const td = document.createElement("td");
                    td.style.cssText = "padding: 6px; border: 1px solid var(--border); min-width: 80px;";
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = rowCells[idx] || "";
                    input.style.cssText = "width: 100%; padding: 4px 8px; background: rgba(15, 23, 42, 0.5); border: 1px solid rgba(56, 189, 248, 0.2); border-radius: 4px; color: var(--text); font-size: 13px; box-sizing: border-box;";
                    input.addEventListener("mousedown", (e) => e.stopPropagation());
                    input.addEventListener("click", (e) => e.stopPropagation());
                    input.oninput = () => {
                      if (!tableData[i]) tableData[i] = [];
                      tableData[i][idx] = input.value;
                      updateFieldValue();
                    };
                    td.appendChild(input);
                    tr.appendChild(td);
                  }
                  table.appendChild(tr);
                }
                
                tableEditor.appendChild(table);
                
                // Function to update field value from table data
                function updateFieldValue() {
                  const markdown = tableToMarkdown(tableData);
                  if (field._occurrences) {
                    const occ = field._occurrences.find(o => o.region && o.region.page === currentPageNum);
                    if (occ) {
                      occ.value = markdown;
                    }
                  } else {
                    field.value = markdown;
                  }
                }
                
                valueContainer.innerHTML = "";
                valueContainer.appendChild(tableEditor);
              } else {
                // Show textarea for non-table editing
                const textarea = document.createElement("textarea");
                textarea.className = "field-value-input";
                textarea.value = valueToRender;
                textarea.style.width = "100%";
                textarea.style.minHeight = "80px";
                textarea.style.maxHeight = "400px";
                
                // Prevent textarea events from triggering document selection
                textarea.addEventListener("mousedown", (e) => e.stopPropagation());
                textarea.addEventListener("mouseup", (e) => e.stopPropagation());
                textarea.addEventListener("mousemove", (e) => e.stopPropagation());
                textarea.addEventListener("click", (e) => e.stopPropagation());
                
                textarea.onchange = (e) => {
                  // Update the occurrence for current page
                  if (field._occurrences) {
                    const occ = field._occurrences.find(o => o.region && o.region.page === currentPageNum);
                    if (occ) {
                      occ.value = e.target.value;
                    }
                  } else {
                    field.value = e.target.value;
                  }
                };
                textarea.oninput = (e) => {
                  // Update the occurrence for current page
                  if (field._occurrences) {
                    const occ = field._occurrences.find(o => o.region && o.region.page === currentPageNum);
                    if (occ) {
                      occ.value = e.target.value;
                    }
                  } else {
                    field.value = e.target.value;
                  }
                };
                
                valueContainer.innerHTML = "";
                valueContainer.appendChild(textarea);
              }
            } else {
              // View mode
              const valueToRender = fieldValueToShow || field.value || "";
              
              if (isTable) {
                // For tables, show compact preview with View/Edit buttons
                const previewContainer = document.createElement("div");
                previewContainer.style.cssText = "padding: 12px; background: rgba(15, 23, 42, 0.3); border-radius: 8px; border: 1px solid var(--border);";
                
                // Show table preview (first 2 rows)
                const tableData = parseMarkdownTable(valueToRender);
                const previewRows = Math.min(2, tableData.length);
                const previewText = tableData.slice(0, previewRows).map(row => row.join(' | ')).join('\n');
                
                const previewTextEl = document.createElement("div");
                previewTextEl.style.cssText = "font-size: 11px; color: var(--subtle); font-family: monospace; margin-bottom: 8px; max-height: 50px; overflow: hidden; line-height: 1.4;";
                previewTextEl.textContent = previewText + (tableData.length > previewRows ? ' ...' : '');
                
                const buttonsContainer = document.createElement("div");
                buttonsContainer.style.cssText = "display: flex; gap: 6px;";
                
                const viewBtn = document.createElement("button");
                viewBtn.textContent = "View";
                viewBtn.style.cssText = "padding: 4px 10px; font-size: 11px; background: rgba(56, 189, 248, 0.2); color: var(--accent); border: 1px solid var(--accent); border-radius: 4px; cursor: pointer;";
                viewBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  openTableModal(field, valueToRender, false);
                });
                
                const editBtn = document.createElement("button");
                editBtn.textContent = "Edit";
                editBtn.style.cssText = "padding: 4px 10px; font-size: 11px; background: var(--accent); color: white; border: none; border-radius: 4px; cursor: pointer;";
                editBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  openTableModal(field, valueToRender, true);
                });
                
                buttonsContainer.appendChild(viewBtn);
                buttonsContainer.appendChild(editBtn);
                
                previewContainer.appendChild(previewTextEl);
                previewContainer.appendChild(buttonsContainer);
                
                valueContainer.innerHTML = "";
                valueContainer.appendChild(previewContainer);
              } else {
                // Render markdown for non-table content
                let html = "";
                if (typeof marked !== 'undefined') {
                  html = marked.parse(valueToRender);
                } else {
                  html = escapeHtml(valueToRender).replace(/\n/g, '<br>');
                }
                
                const markdownContent = document.createElement("div");
                markdownContent.className = "field-value-markdown";
                markdownContent.style.cssText = "padding: 12px; background: rgba(15, 23, 42, 0.3); border-radius: 8px; border: 1px solid var(--border); overflow-x: auto;";
                markdownContent.innerHTML = html;
                
                // Add edit button for non-table content
                const editBtn = document.createElement("button");
                editBtn.textContent = "Edit";
                editBtn.style.cssText = "position: absolute; top: 8px; right: 8px; padding: 4px 8px; font-size: 11px; background: var(--accent); color: white; border: none; border-radius: 4px; cursor: pointer; z-index: 10;";
                editBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  isEditing = true;
                  renderValue();
                });
                
                valueContainer.innerHTML = "";
                valueContainer.appendChild(markdownContent);
                valueContainer.appendChild(editBtn);
              }
            }
            
            // Add save button if editing (non-table)
            if (isEditing && !isTable) {
              const saveBtn = document.createElement("button");
              saveBtn.textContent = "Save";
              saveBtn.style.cssText = "position: absolute; top: 8px; right: 8px; padding: 4px 8px; font-size: 11px; background: var(--accent); color: white; border: none; border-radius: 4px; cursor: pointer; z-index: 10;";
              saveBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                isEditing = false;
                renderValue();
              });
              valueContainer.appendChild(saveBtn);
            }
          }
          
          // Function to open table modal for viewing/editing
          function openTableModal(field, tableValue, editMode) {
            // Remove existing modal if any
            const existingModal = document.getElementById("tableModal");
            if (existingModal) {
              document.body.removeChild(existingModal);
            }
            
            const tableModal = document.createElement("div");
            tableModal.id = "tableModal";
            tableModal.style.cssText = `
              display: flex;
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.75);
              z-index: 10000;
              align-items: center;
              justify-content: center;
              padding: 20px;
            `;
            
            const modalContent = document.createElement("div");
            modalContent.style.cssText = `
              background: var(--card);
              border-radius: 12px;
              border: 1px solid var(--border);
              max-width: 98%;
              max-height: 90vh;
              width: 100%;
              display: flex;
              flex-direction: column;
              overflow: hidden;
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            `;
            
            const modalHeader = document.createElement("div");
            modalHeader.style.cssText = "padding: 16px 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;";
            modalHeader.innerHTML = `
              <h3 style="margin: 0; font-size: 1.1rem; color: var(--text);">${escapeHtml(field.name)} ${editMode ? '(Editing)' : '(Viewing)'}</h3>
              <button id="closeTableModal" style="background: transparent; border: none; color: var(--text); font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px; line-height: 24px;">×</button>
            `;
            
            const modalBody = document.createElement("div");
            modalBody.style.cssText = "padding: 20px; overflow-x: auto; overflow-y: auto; flex: 1; background: var(--bg); min-height: 0; position: relative;";
            
            let tableData = parseMarkdownTable(tableValue);
            let isEditingInModal = editMode;
            
            function renderTableInModal() {
              modalBody.innerHTML = "";
              
              if (isEditingInModal) {
                // Editable table
                const tableEditor = document.createElement("div");
                tableEditor.className = "table-editor";
                tableEditor.style.cssText = "overflow-x: auto; width: 100%; min-width: 100%;";
                
                const table = document.createElement("table");
                table.style.cssText = "width: auto; min-width: 100%; border-collapse: collapse; background: rgba(15, 23, 42, 0.3); font-size: 13px; table-layout: auto;";
                
                // Header row
                if (tableData.length > 0) {
                  const headerRow = document.createElement("tr");
                  tableData[0].forEach((cell, idx) => {
                    const th = document.createElement("th");
                    th.style.cssText = "padding: 10px; border: 1px solid var(--border); background: rgba(56, 189, 248, 0.15); text-align: left; min-width: 120px; white-space: nowrap;";
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = cell || "";
                    input.style.cssText = "width: 100%; padding: 6px 8px; background: transparent; border: none; color: var(--text); font-weight: 600; font-size: 13px; box-sizing: border-box;";
                    input.addEventListener("mousedown", (e) => e.stopPropagation());
                    input.addEventListener("click", (e) => e.stopPropagation());
                    input.oninput = () => {
                      tableData[0][idx] = input.value;
                    };
                    th.appendChild(input);
                    headerRow.appendChild(th);
                  });
                  table.appendChild(headerRow);
                }
                
                // Body rows
                for (let i = 1; i < tableData.length; i++) {
                  const tr = document.createElement("tr");
                  const expectedCols = tableData[0] ? tableData[0].length : 0;
                  const rowCells = tableData[i] || [];
                  for (let idx = 0; idx < Math.max(expectedCols, rowCells.length); idx++) {
                    const td = document.createElement("td");
                    td.style.cssText = "padding: 8px; border: 1px solid var(--border); min-width: 100px; white-space: nowrap;";
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = rowCells[idx] || "";
                    input.style.cssText = "width: 100%; padding: 6px 8px; background: rgba(15, 23, 42, 0.5); border: 1px solid rgba(56, 189, 248, 0.2); border-radius: 4px; color: var(--text); font-size: 13px; box-sizing: border-box;";
                    input.addEventListener("mousedown", (e) => e.stopPropagation());
                    input.addEventListener("click", (e) => e.stopPropagation());
                    input.oninput = () => {
                      if (!tableData[i]) tableData[i] = [];
                      tableData[i][idx] = input.value;
                    };
                    td.appendChild(input);
                    tr.appendChild(td);
                  }
                  table.appendChild(tr);
                }
                
                tableEditor.appendChild(table);
                modalBody.appendChild(tableEditor);
              } else {
                // View mode - render markdown table with full width and horizontal scroll
                let html = "";
                if (typeof marked !== 'undefined') {
                  html = marked.parse(tableValue);
                } else {
                  html = escapeHtml(tableValue).replace(/\n/g, '<br>');
                }
                
                // Create scrollable wrapper - must allow content to overflow
                const scrollWrapper = document.createElement("div");
                scrollWrapper.style.cssText = "overflow-x: auto; overflow-y: visible; width: 100%; min-width: 0; -webkit-overflow-scrolling: touch; position: relative;";
                
                const markdownContent = document.createElement("div");
                markdownContent.className = "field-value-markdown";
                markdownContent.style.cssText = "padding: 16px; display: block; width: max-content; min-width: 100%;";
                markdownContent.innerHTML = html;
                
                // Fix table display - ensure all columns are visible
                setTimeout(() => {
                  const tables = markdownContent.querySelectorAll('table');
                  tables.forEach(tbl => {
                    // Remove ALL width restrictions
                    tbl.style.setProperty('width', 'auto', 'important');
                    tbl.style.setProperty('min-width', 'auto', 'important');
                    tbl.style.setProperty('max-width', 'none', 'important');
                    tbl.style.setProperty('table-layout', 'auto', 'important');
                    tbl.style.borderCollapse = 'collapse';
                    tbl.style.display = 'table';
                    
                    // Get all rows and cells
                    const rows = Array.from(tbl.querySelectorAll('tr'));
                    if (rows.length === 0) return;
                    
                    // Get column count from first row
                    const firstRowCells = rows[0].querySelectorAll('th, td');
                    const colCount = firstRowCells.length;
                    if (colCount === 0) return;
                    
                    // Calculate width for each column based on content
                    const columnWidths = [];
                    for (let colIdx = 0; colIdx < colCount; colIdx++) {
                      let maxWidth = 0;
                      
                      // Check all cells in this column
                      rows.forEach(row => {
                        const cells = row.querySelectorAll('th, td');
                        if (cells[colIdx]) {
                          const cell = cells[colIdx];
                          
                          // Remove any width restrictions temporarily
                          const oldWidth = cell.style.width;
                          const oldMinWidth = cell.style.minWidth;
                          const oldMaxWidth = cell.style.maxWidth;
                          cell.style.width = 'auto';
                          cell.style.minWidth = 'auto';
                          cell.style.maxWidth = 'none';
                          cell.style.whiteSpace = 'nowrap';
                          
                          // Measure the cell content
                          const text = cell.textContent || cell.innerText || '';
                          const tempDiv = document.createElement('div');
                          tempDiv.style.cssText = `
                            position: absolute;
                            visibility: hidden;
                            white-space: nowrap;
                            font-size: 13px;
                            font-weight: ${cell.tagName === 'TH' ? '600' : '400'};
                            padding: ${cell.tagName === 'TH' ? '10px 12px' : '8px 12px'};
                            font-family: "Inter", system-ui, -apple-system, sans-serif;
                          `;
                          tempDiv.textContent = text;
                          document.body.appendChild(tempDiv);
                          const contentWidth = tempDiv.offsetWidth;
                          document.body.removeChild(tempDiv);
                          
                          // Restore old styles
                          cell.style.width = oldWidth;
                          cell.style.minWidth = oldMinWidth;
                          cell.style.maxWidth = oldMaxWidth;
                          
                          maxWidth = Math.max(maxWidth, contentWidth);
                        }
                      });
                      
                      // Set minimum width per column
                      columnWidths.push(Math.max(maxWidth + 20, 100));
                    }
                    
                    // Apply calculated widths to all cells
                    rows.forEach(row => {
                      const cells = row.querySelectorAll('th, td');
                      cells.forEach((cell, idx) => {
                        if (columnWidths[idx]) {
                          cell.style.setProperty('width', columnWidths[idx] + 'px', 'important');
                          cell.style.setProperty('min-width', columnWidths[idx] + 'px', 'important');
                          cell.style.setProperty('max-width', 'none', 'important');
                          cell.style.setProperty('white-space', 'nowrap', 'important');
                        }
                      });
                    });
                    
                    // Set total table width
                    const totalWidth = columnWidths.reduce((sum, w) => sum + w, 0);
                    tbl.style.setProperty('width', totalWidth + 'px', 'important');
                    
                    // Ensure markdownContent is wide enough
                    markdownContent.style.width = Math.max(totalWidth + 32, scrollWrapper.offsetWidth) + 'px';
                  });
                }, 100);
                
                scrollWrapper.appendChild(markdownContent);
                modalBody.appendChild(scrollWrapper);
              }
            }
            
            const modalFooter = document.createElement("div");
            modalFooter.style.cssText = "padding: 16px 20px; border-top: 1px solid var(--border); display: flex; gap: 8px; justify-content: flex-end;";
            
            function updateFooter() {
              modalFooter.innerHTML = "";
              
              if (isEditingInModal) {
                const saveBtn = document.createElement("button");
                saveBtn.textContent = "Save";
                saveBtn.style.cssText = "padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;";
                saveBtn.addEventListener("click", () => {
                  const markdown = tableToMarkdown(tableData);
                  // Update field value
                  if (field._occurrences) {
                    const occ = field._occurrences.find(o => o.region && o.region.page === currentPageNum);
                    if (occ) {
                      occ.value = markdown;
                    }
                  } else {
                    field.value = markdown;
                  }
                  renderFields(); // Refresh display
                  document.body.removeChild(tableModal);
                });
                
                const cancelBtn = document.createElement("button");
                cancelBtn.textContent = "Cancel";
                cancelBtn.style.cssText = "padding: 8px 16px; background: transparent; color: var(--text); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 13px;";
                cancelBtn.addEventListener("click", () => {
                  document.body.removeChild(tableModal);
                });
                
                modalFooter.appendChild(cancelBtn);
                modalFooter.appendChild(saveBtn);
              } else {
                const editBtn = document.createElement("button");
                editBtn.textContent = "Edit";
                editBtn.style.cssText = "padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;";
                editBtn.addEventListener("click", () => {
                  isEditingInModal = true;
                  renderTableInModal();
                  updateFooter();
                });
                
                const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.cssText = "padding: 8px 16px; background: transparent; color: var(--text); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 13px;";
                closeBtn.addEventListener("click", () => {
                  document.body.removeChild(tableModal);
                });
                
                modalFooter.appendChild(closeBtn);
                modalFooter.appendChild(editBtn);
              }
            }
            
            modalContent.appendChild(modalHeader);
            modalContent.appendChild(modalBody);
            modalContent.appendChild(modalFooter);
            tableModal.appendChild(modalContent);
            
            document.body.appendChild(tableModal);
            
            // Close on X button
            document.getElementById("closeTableModal").addEventListener("click", () => {
              document.body.removeChild(tableModal);
            });
            
            // Close on background click
            tableModal.addEventListener("click", (e) => {
              if (e.target === tableModal) {
                document.body.removeChild(tableModal);
              }
            });
            
            // Close on Escape key
            const escapeHandler = (e) => {
              if (e.key === 'Escape' && document.getElementById("tableModal")) {
                document.body.removeChild(tableModal);
                document.removeEventListener("keydown", escapeHandler);
              }
            };
            document.addEventListener("keydown", escapeHandler);
            
            renderTableInModal();
            updateFooter();
          }
          
          renderValue();
          tdValue.appendChild(valueContainer);
        }

        // Show coordinates only if field is on current page
        let coordsText = "";
        if (shouldShowValue && fieldRegionToShow && fieldRegionToShow.page === currentPageNum) {
          const r = fieldRegionToShow;
          // Check that all coordinates exist before calling toFixed
          if (r.x1 != null && r.y1 != null && r.x2 != null && r.y2 != null) {
            coordsText = `\n\n(page=${r.page}, x1=${r.x1.toFixed(3)}, y1=${r.y1.toFixed(3)}, x2=${r.x2.toFixed(3)}, y2=${r.y2.toFixed(3)})`;
          } else {
            coordsText = `\n\n(page=${r.page})`;
          }
        } else if (field._occurrences && field._occurrences.length > 0) {
          // Show that field exists on other pages
          const pages = field._occurrences.map(occ => occ.page_number).filter(p => p).join(", ");
          if (pages) {
            coordsText = `\n\n(pages: ${pages})`;
          }
        }
        if (coordsText) {
          const coordsDiv = document.createElement("div");
          coordsDiv.className = "small";
          coordsDiv.textContent = coordsText.trim();
          tdValue.appendChild(coordsDiv);
        }

        // Add delete button
        const tdActions = document.createElement("td");
        tdActions.style.width = "80px";
        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Delete";
        deleteBtn.style.padding = "4px 8px";
        deleteBtn.style.fontSize = "11px";
        deleteBtn.style.background = "var(--error)";
        deleteBtn.style.color = "white";
        deleteBtn.style.border = "none";
        deleteBtn.style.borderRadius = "4px";
        deleteBtn.style.cursor = "pointer";
        deleteBtn.onclick = async (e) => {
          e.stopPropagation();
          
          // Determine which occurrence to delete - prefer current page's occurrence
          let occurrenceToDelete = null;
          if (field._occurrences && field._occurrences.length > 0) {
            // Find occurrence for current page
            occurrenceToDelete = field._occurrences.find(occ => 
              occ.region && occ.region.page === currentPageNum
            );
            console.log("Delete: current page", currentPageNum, "occurrenceToDelete:", occurrenceToDelete, "all occurrences:", field._occurrences.map(o => ({ id: o.id, page: o.region?.page })));
          }
          
          // Determine what to delete
          const hasMultipleOccurrences = field._occurrences && field._occurrences.length > 1;
          const hasOccurrenceOnCurrentPage = occurrenceToDelete !== null;
          
          let confirmMessage = '';
          if (hasMultipleOccurrences && hasOccurrenceOnCurrentPage) {
            confirmMessage = `Delete occurrence of "${field.name}" on page ${currentPageNum}?`;
          } else {
            confirmMessage = `Delete field "${field.name}"?`;
          }
          
          if (!confirm(confirmMessage)) return;

          try {
            if (hasMultipleOccurrences && hasOccurrenceOnCurrentPage) {
              // Delete only the occurrence for current page
              const occurrenceId = occurrenceToDelete.id;
              console.log("Deleting occurrence ID:", occurrenceId, "for page", currentPageNum);
              
              if (occurrenceId) {
                // Delete from server
                const response = await fetch(`/documents/field-values/${occurrenceId}`, {
                  method: 'DELETE'
                });
                const result = await response.json();
                console.log("Delete response:", result);
                if (!result.success) {
                  alert('Error deleting occurrence');
                  return;
                }
              } else {
                console.warn("No ID for occurrence on page", currentPageNum, "- removing from local array only");
              }
              
              // Remove occurrence from local array
              field._occurrences = field._occurrences.filter(occ => 
                !(occ.region && occ.region.page === currentPageNum)
              );
              
              // If no occurrences left, remove the field entirely
              if (field._occurrences.length === 0) {
                fields = fields.filter((_, i) => i !== index);
              }
              
              // Remove bbox from current page
              const boxesToRemove = pdfViewerWrapper.querySelectorAll(
                `.selection-box[data-field-index="${index}"][data-page-index="${currentPageNum}"]`
              );
              boxesToRemove.forEach(box => box.remove());
              
              await loadFields(); // Reload to sync with server
              await renderPage(currentPageNum); // Re-render current page
            } else {
              // Delete entire field - delete all occurrences
              if (field._occurrences && field._occurrences.length > 0) {
                // Delete all occurrences from server
                const deletePromises = field._occurrences
                  .filter(occ => occ.id)
                  .map(occ => 
                    fetch(`/documents/field-values/${occ.id}`, { method: 'DELETE' })
                      .then(res => res.json())
                  );
                
                if (deletePromises.length > 0) {
                  const results = await Promise.all(deletePromises);
                  const allSuccess = results.every(r => r.success);
                  if (!allSuccess) {
                    alert('Error deleting some occurrences');
                    return;
                  }
                }
                
                // Remove all bboxes for this field
                const boxesToRemove = pdfViewerWrapper.querySelectorAll(
                  `.selection-box[data-field-index="${index}"]`
                );
                boxesToRemove.forEach(box => box.remove());
                
                // Remove from local array
                fields = fields.filter((_, i) => i !== index);
                await loadFields(); // Reload to sync with server
                await renderPage(currentPageNum); // Re-render current page
              } else if (field.id) {
                // Backward compatibility - single occurrence with field.id
                const response = await fetch(`/documents/field-values/${field.id}`, {
                  method: 'DELETE'
                });
                const result = await response.json();
                if (result.success) {
                  // Remove from local array
                  fields = fields.filter((_, i) => i !== index);
                  await loadFields(); // Reload to sync with server
                  await renderPage(currentPageNum); // Re-render current page
                } else {
                  alert('Error deleting field');
                }
              } else {
                // Just remove from local array if no id (not saved yet)
                fields = fields.filter((_, i) => i !== index);
                renderFields();
                await renderPage(currentPageNum);
              }
            }
          } catch (error) {
            console.error('Error deleting:', error);
            alert('Error deleting: ' + error.message);
          }
        };
        tdActions.appendChild(deleteBtn);

        tr.appendChild(tdName);
        tr.appendChild(tdValue);
        tr.appendChild(tdActions);
        fieldsTableBody.appendChild(tr);

        tr.addEventListener("click", (e) => {
          // Don't trigger selection if clicking on interactive elements
          if (e.target.tagName === 'TEXTAREA' ||
            e.target.tagName === 'BUTTON' ||
            e.target.tagName === 'INPUT' ||
            e.target.closest('.field-value-container') ||
            e.target.closest('.field-value-markdown')) {
            return;
          }
          startSelectionForField(index);
        });
      });

      // Update box visibility
      const anyActive = activeFieldIndex !== null;
      document.querySelectorAll(".selection-box").forEach((box) => {
        const fi = Number(box.dataset.fieldIndex);
        const isActive = fi === activeFieldIndex;
        box.classList.toggle("active", isActive);
        if (anyActive) {
          if (isActive) {
            box.classList.remove("hidden");
          } else {
            box.classList.add("hidden");
          }
        } else {
          box.classList.remove("hidden");
        }
        if (!anyActive || !isActive) {
          box.classList.add("handles-hidden");
        } else {
          box.classList.remove("handles-hidden");
        }
      });
    }

    async function startSelectionForField(index) {
      if (!pdfDoc) {
        alert("PDF not loaded.");
        return;
      }
      activeFieldIndex = index;
      const field = fields[index];
      selectionMode = true;
      clearAllOverlays();
      pdfViewerWrapper.classList.remove("global-dim");
      document.querySelectorAll(".selection-box").forEach((b) =>
        b.classList.remove("editing")
      );

      // Determine which occurrence to use - ALWAYS prefer current page's occurrence
      let regionToUse = null;
      let occurrenceToUse = null;
      
      if (field._occurrences && field._occurrences.length > 0) {
        // ALWAYS find occurrence for current page first - stay on current page!
        occurrenceToUse = field._occurrences.find(occ => 
          occ.region && occ.region.page === currentPageNum
        );
        
        if (occurrenceToUse && occurrenceToUse.region) {
          regionToUse = occurrenceToUse.region;
        }
      } else if (field.region && field.region.page === currentPageNum) {
        // Backward compatibility - only use field.region if it's on current page
        regionToUse = field.region;
      }

      if (regionToUse) {
        // Found occurrence on current page - stay here and edit it
        createMode = false;
        editMode = true;
        const r = regionToUse;
        // Don't change page - stay on currentPageNum
        const pageDiv = currentPageDiv;
        const canvas = currentPageCanvas;
        if (!pageDiv || !canvas) return;
        currentPageIndex = currentPageNum; // Use current page, not r.page

        // Find or create box for this field and current page
        let box = pdfViewerWrapper.querySelector(
          `.selection-box[data-field-index="${index}"][data-page-index="${currentPageNum}"]`
        );
        if (!box) {
          const left = r.x1 * canvas.width;
          const top = r.y1 * canvas.height;
          const width = (r.x2 - r.x1) * canvas.width;
          const height = (r.y2 - r.y1) * canvas.height;
          box = createSelectionBox(left, top, width, height, index, currentPageNum);
          pageDiv.appendChild(box);
        }
        box.classList.add("active", "editing");
        box.classList.remove("handles-hidden", "hidden");
        currentSelectionBox = box;

        // Store original region for cancel AFTER box is created and positioned
        originalRegion = {
          page: currentPageNum, // Store current page, not r.page
          x1: r.x1,
          y1: r.y1,
          x2: r.x2,
          y2: r.y2
        };
        console.log("startSelectionForField: stored originalRegion", originalRegion, "for field index", index, "on current page", currentPageNum);

        updateOverlays(pageDiv, box);
      } else {
        // No occurrence on current page - stay on current page and allow creating new one
        createMode = true;
        editMode = false;
        currentPageDiv = currentPageDiv || pdfViewerWrapper.querySelector(".page");
        currentPageCanvas = currentPageDiv
          ? currentPageDiv.querySelector("canvas")
          : null;
        currentPageIndex = currentPageNum; // Stay on current page
        currentSelectionBox = null;
        pdfViewerWrapper.classList.add("global-dim");
        console.log("startSelectionForField: no occurrence on current page", currentPageNum, "- allowing creation");
      }
      renderFields();
    }

    function setupPageSelection(pageDiv) {
      pageDiv.addEventListener("mousedown", (e) => {
        if (!selectionMode || !createMode || isProcessing) return;
        if (activeFieldIndex === null) return;
        e.preventDefault();
        isDragging = true;
        dragType = "create";
        currentPageDiv = pageDiv;
        currentPageCanvas = pageDiv.querySelector("canvas");
        currentPageIndex = currentPageNum;
        const rect = pageDiv.getBoundingClientRect();
        dragStartX = e.clientX - rect.left;
        dragStartY = e.clientY - rect.top;
        pdfViewerWrapper.classList.remove("global-dim");
        currentSelectionBox = createSelectionBox(
          dragStartX,
          dragStartY,
          0,
          0,
          activeFieldIndex,
          currentPageIndex
        );
        currentSelectionBox.classList.add("editing");
        currentSelectionBox.classList.remove("handles-hidden");
        pageDiv.appendChild(currentSelectionBox);
        clearAllOverlays();
        updateOverlays(pageDiv, currentSelectionBox);
      });
    }

    function createSelectionBox(left, top, width, height, fieldIndex, pageIndex) {
      const box = document.createElement("div");
      box.className = "selection-box";
      box.style.left = left + "px";
      box.style.top = top + "px";
      box.style.width = width + "px";
      box.style.height = height + "px";
      box.dataset.fieldIndex = String(fieldIndex);
      box.dataset.pageIndex = String(pageIndex);

      const hNW = document.createElement("div");
      hNW.className = "resize-handle resize-nw";
      const hNE = document.createElement("div");
      hNE.className = "resize-handle resize-ne";
      const hSW = document.createElement("div");
      hSW.className = "resize-handle resize-sw";
      const hSE = document.createElement("div");
      hSE.className = "resize-handle resize-se";

      box.appendChild(hNW);
      box.appendChild(hNE);
      box.appendChild(hSW);
      box.appendChild(hSE);

      if (activeFieldIndex === null || activeFieldIndex !== fieldIndex) {
        box.classList.add("handles-hidden");
      }

      attachBoxInteractions(box);
      return box;
    }

    // Drag/resize handlers
    window.addEventListener("mousemove", (e) => {
      if (!isDragging || !selectionMode || !currentPageDiv || !currentSelectionBox || isProcessing) return;
      const rect = currentPageDiv.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (dragType === "create") {
        const left = Math.min(dragStartX, x);
        const top = Math.min(dragStartY, y);
        const width = Math.abs(x - dragStartX);
        const height = Math.abs(y - dragStartY);
        currentSelectionBox.style.left = left + "px";
        currentSelectionBox.style.top = top + "px";
        currentSelectionBox.style.width = width + "px";
        currentSelectionBox.style.height = height + "px";
        updateOverlays(currentPageDiv, currentSelectionBox);
      } else if (dragType === "move") {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        let newLeft = startLeft + dx;
        let newTop = startTop + dy;
        newLeft = Math.max(0, Math.min(newLeft, rect.width - startWidth));
        newTop = Math.max(0, Math.min(newTop, rect.height - startHeight));
        currentSelectionBox.style.left = newLeft + "px";
        currentSelectionBox.style.top = newTop + "px";
        updateOverlays(currentPageDiv, currentSelectionBox);
      } else if (dragType && dragType.startsWith("resize-")) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        let newLeft = startLeft;
        let newTop = startTop;
        let newWidth = startWidth;
        let newHeight = startHeight;

        if (dragType === "resize-se") {
          newWidth = startWidth + dx;
          newHeight = startHeight + dy;
        } else if (dragType === "resize-sw") {
          newWidth = startWidth - dx;
          newHeight = startHeight + dy;
          newLeft = startLeft + dx;
        } else if (dragType === "resize-ne") {
          newWidth = startWidth + dx;
          newHeight = startHeight - dy;
          newTop = startTop + dy;
        } else if (dragType === "resize-nw") {
          newWidth = startWidth - dx;
          newHeight = startHeight - dy;
          newLeft = startLeft + dx;
          newTop = startTop + dy;
        }

        newWidth = Math.max(5, newWidth);
        newHeight = Math.max(5, newHeight);
        if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
        if (newTop < 0) { newHeight += newTop; newTop = 0; }
        if (newLeft + newWidth > rect.width) { newWidth = rect.width - newLeft; }
        if (newTop + newHeight > rect.height) { newHeight = rect.height - newTop; }

        currentSelectionBox.style.left = newLeft + "px";
        currentSelectionBox.style.top = newTop + "px";
        currentSelectionBox.style.width = newWidth + "px";
        currentSelectionBox.style.height = newHeight + "px";
        updateOverlays(currentPageDiv, currentSelectionBox);
      }
    });

    window.addEventListener("mouseup", async (e) => {
      // Don't process if clicking on textarea or its resize handle
      if (e.target.tagName === 'TEXTAREA' || e.target.closest('textarea')) {
        return;
      }
      // Don't process if clicking on confirm buttons or their children
      if (e.target.closest('.selection-confirm-buttons') ||
        e.target.classList.contains('btn-confirm') ||
        e.target.classList.contains('btn-cancel') ||
        e.target.tagName === 'BUTTON' && e.target.closest('.selection-confirm-buttons')) {
        return;
      }
      if (!isDragging || !selectionMode || !currentPageDiv || !currentSelectionBox || isProcessing) return;
      isDragging = false;
      const rect = currentPageDiv.getBoundingClientRect();
      const boxRect = currentSelectionBox.getBoundingClientRect();
      const left = boxRect.left - rect.left;
      const top = boxRect.top - rect.top;
      const width = boxRect.width;
      const height = boxRect.height;

      if (width < 5 || height < 5 || activeFieldIndex === null) {
        if (dragType === "create" && currentSelectionBox.parentNode) {
          currentSelectionBox.parentNode.removeChild(currentSelectionBox);
        }
        resetSelectionState(true);
        return;
      }

      // For edit mode (move/resize), show confirm buttons - don't extract yet
      if (editMode && dragType !== "create") {
        showConfirmButtons(currentSelectionBox);
        return;
      }

      // For create mode, extract immediately
      if (dragType === "create") {
        await extractRegionAndUpdateField();
      }
    });

    // Extract region and update field (called on confirm or create)
    async function extractRegionAndUpdateField() {
      console.log("extractRegionAndUpdateField called", {
        hasPageDiv: !!currentPageDiv,
        hasSelectionBox: !!currentSelectionBox,
        activeFieldIndex,
        isProcessing
      });

      if (!currentPageDiv || !currentSelectionBox || activeFieldIndex === null || isProcessing) {
        console.log("extractRegionAndUpdateField: early return");
        return;
      }

      const rect = currentPageDiv.getBoundingClientRect();
      const boxRect = currentSelectionBox.getBoundingClientRect();
      const left = boxRect.left - rect.left;
      const top = boxRect.top - rect.top;
      const width = boxRect.width;
      const height = boxRect.height;

      if (width < 5 || height < 5) {
        hideConfirmButtons();
        return;
      }

      const cw = currentPageCanvas.width;
      const ch = currentPageCanvas.height;
      const x1Norm = left / cw;
      const y1Norm = top / ch;
      const x2Norm = (left + width) / cw;
      const y2Norm = (top + height) / ch;

      const fieldIndex = activeFieldIndex;
      const fld = fields[fieldIndex];
      
      // Determine which occurrence to update - prefer current page's occurrence
      let occurrenceToUpdate = null;
      if (fld._occurrences && fld._occurrences.length > 0) {
        // Find occurrence for current page - check both region.page and page_number
        occurrenceToUpdate = fld._occurrences.find(occ => 
          (occ.region && occ.region.page === currentPageIndex) || 
          occ.page_number === currentPageIndex
        );
        
        console.log("Looking for occurrence on page", currentPageIndex, "found:", occurrenceToUpdate, "all occurrences:", fld._occurrences.map(o => ({ 
          id: o.id, 
          page_from_region: o.region?.page, 
          page_number: o.page_number 
        })));
        
        // If no occurrence on current page, create a new one
        if (!occurrenceToUpdate) {
          occurrenceToUpdate = {
            id: null,
            value: null,
            region: null,
            page_number: currentPageIndex
          };
          if (!fld._occurrences) {
            fld._occurrences = [];
          }
          fld._occurrences.push(occurrenceToUpdate);
          console.log("Created new occurrence for page", currentPageIndex);
        } else {
          console.log("Found existing occurrence to update:", occurrenceToUpdate.id);
        }
      } else {
        // No occurrences array - initialize it and create first occurrence
        if (!fld._occurrences) {
          fld._occurrences = [];
        }
        occurrenceToUpdate = {
          id: fld.id || null, // Use field.id if available (backward compatibility)
          value: fld.value || null,
          region: fld.region || null,
          page_number: currentPageIndex
        };
        fld._occurrences.push(occurrenceToUpdate);
        console.log("Initialized occurrences array and added first occurrence");
      }

      // Set processing state
      isProcessing = true;
      hideConfirmButtons();
      showProcessingOverlay(currentSelectionBox);

      // Disable interactions
      currentSelectionBox.style.pointerEvents = "none";
      if (confirmButtonsContainer) {
        const buttons = confirmButtonsContainer.querySelectorAll('button');
        buttons.forEach(btn => btn.disabled = true);
      }

      // Show processing state in field - only for the specific occurrence
      if (occurrenceToUpdate) {
        occurrenceToUpdate._processing = true;
        occurrenceToUpdate.value = "processing...";
      } else {
        fld._processing = true;
        fld.value = "processing...";
      }
      renderFields();

      try {
        // Extract selected region from canvas as image
        const cropCanvas = document.createElement("canvas");
        cropCanvas.width = width;
        cropCanvas.height = height;
        const cropCtx = cropCanvas.getContext("2d");

        // Draw the selected region to crop canvas
        cropCtx.drawImage(currentPageCanvas, left, top, width, height, 0, 0, width, height);

        // Convert to blob (PNG image)
        const blob = await new Promise((resolve) => {
          cropCanvas.toBlob(resolve, "image/png");
        });

        if (!blob) {
          throw new Error("Failed to create image blob");
        }

        // Send crop image to backend for processing
        const formData = new FormData();
        formData.append("image", blob, "region.png");
        formData.append("document_id", documentId);
        formData.append("page_number", currentPageIndex.toString());

        console.log("Sending region image for processing...");
        const response = await fetch("/document-ai/extract-region", {
          method: "POST",
          body: formData,
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
        }

        const result = await response.json();
        console.log("Extraction result:", result);

        // Use markdown if available (includes tables), otherwise use plain text
        const extractedText = result.markdown || result.text || "";

        console.log("Extracted text:", extractedText);
        console.log("Text length:", extractedText.length);

        if (!extractedText) {
          console.warn("No text extracted from region");
          console.warn("Result object:", JSON.stringify(result, null, 2));
        }

        // If tables were found, we can display them nicely
        if (result.tables && result.tables.length > 0) {
          console.log(`Found ${result.tables.length} table(s) in selected region`);
        }

        // Update the correct occurrence for current page
        const newRegion = {
          page: currentPageIndex,
          x1: x1Norm,
          y1: y1Norm,
          x2: x2Norm,
          y2: y2Norm,
        };
        
        if (occurrenceToUpdate) {
          // Update existing occurrence
          occurrenceToUpdate.value = extractedText || "";
          occurrenceToUpdate.region = newRegion;
          occurrenceToUpdate.page_number = currentPageIndex;
          // Clear processing flag for this occurrence
          delete occurrenceToUpdate._processing;
          console.log("Updated occurrence for page", currentPageIndex, ":", {
            id: occurrenceToUpdate.id,
            value: occurrenceToUpdate.value,
            region: occurrenceToUpdate.region,
            _processing: occurrenceToUpdate._processing
          });
          
          // Save to server immediately
          const fieldValues = [{
            id: occurrenceToUpdate.id || null, // Use existing ID if available
            field_id: fld.field_id || null,
            custom_field_name: fld.custom_field_name || (fld.field_id ? null : fld.name),
            value: occurrenceToUpdate.value,
            confidence: 1.0,
            bbox: occurrenceToUpdate.region ? [
              occurrenceToUpdate.region.x1,
              occurrenceToUpdate.region.y1,
              occurrenceToUpdate.region.x2,
              occurrenceToUpdate.region.y2
            ] : null,
            page_number: occurrenceToUpdate.page_number
          }];
          
          const formData = new FormData();
          formData.append('field_values', JSON.stringify(fieldValues));
          
          try {
            const saveResponse = await fetch(`/documents/${documentId}/save-field-values`, {
              method: 'POST',
              body: formData
            });
            const saveResult = await saveResponse.json();
            if (saveResult.success) {
              console.log("Successfully saved occurrence to server");
              // Reload fields to get updated IDs
              await loadFields();
            } else {
              console.error("Failed to save occurrence:", saveResult.error);
            }
          } catch (saveError) {
            console.error("Error saving occurrence:", saveError);
          }
        } else {
          // Backward compatibility - update field directly
          fld.value = extractedText || "";
          fld.region = newRegion;
          fld._processing = false;
          console.log("Updated field directly:", fld);
        }
        
        isProcessing = false;
        hideProcessingOverlay();
        if (currentSelectionBox) {
          currentSelectionBox.style.pointerEvents = "auto";
        }

        activeFieldIndex = null;
        originalRegion = null;
        
        // Force re-render to update display
        console.log("Rendering fields after extraction...");
        renderFields();
        resetSelectionState(false);
      } catch (err) {
        console.error("Error extracting text from region:", err);
        alert("Ошибка при извлечении текста: " + (err.message || "Неизвестная ошибка"));

        // Clear processing state
        if (occurrenceToUpdate) {
          delete occurrenceToUpdate._processing;
          occurrenceToUpdate.value = null;
        } else {
          fld._processing = false;
          fld.value = null;
        }
        isProcessing = false;
        hideProcessingOverlay();
        if (currentSelectionBox) {
          currentSelectionBox.style.pointerEvents = "auto";
        }

        if (dragType === "create" && currentSelectionBox.parentNode) {
          currentSelectionBox.parentNode.removeChild(currentSelectionBox);
        }
        resetSelectionState(true);
      }
    }

    // Show processing overlay
    function showProcessingOverlay(box) {
      hideProcessingOverlay(); // Remove any existing overlay

      const overlay = document.createElement("div");
      overlay.className = "selection-processing";
      overlay.textContent = "Processing, wait for";
      overlay.id = "processingOverlay";

      const boxParent = box.parentElement;
      if (boxParent) {
        boxParent.appendChild(overlay);
      }
    }

    // Hide processing overlay
    function hideProcessingOverlay() {
      const overlay = document.getElementById("processingOverlay");
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
    }

    function resetSelectionState(removeBox) {
      selectionMode = false;
      createMode = false;
      editMode = false;
      dragType = null;
      clearAllOverlays();
      hideConfirmButtons();
      pdfViewerWrapper.classList.remove("global-dim");
      document.querySelectorAll(".selection-box").forEach((b) =>
        b.classList.remove("editing")
      );
      if (removeBox && currentSelectionBox && currentSelectionBox.parentNode) {
        currentSelectionBox.parentNode.removeChild(currentSelectionBox);
      }
      currentSelectionBox = null;
      originalRegion = null;
      isDragging = false;
    }

    // Show confirm/cancel buttons for selection editing
    function showConfirmButtons(box) {
      hideConfirmButtons(); // Remove any existing buttons

      const container = document.createElement("div");
      container.className = "selection-confirm-buttons";

      const confirmBtn = document.createElement("button");
      confirmBtn.className = "btn-confirm";
      confirmBtn.innerHTML = "✓";
      confirmBtn.title = "Сохранить и запустить OCR";
      confirmBtn.type = "button";
      confirmBtn.onmousedown = (e) => {
        e.preventDefault();
        e.stopPropagation();
      };
      confirmBtn.onclick = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("Confirm button clicked");
        await extractRegionAndUpdateField();
      };

      const cancelBtn = document.createElement("button");
      cancelBtn.className = "btn-cancel";
      cancelBtn.innerHTML = "✕";
      cancelBtn.title = "Отменить изменения";
      cancelBtn.type = "button";
      cancelBtn.onmousedown = (e) => {
        e.preventDefault();
        e.stopPropagation();
      };
      cancelBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("Cancel button clicked");
        cancelSelectionEdit();
      };

      container.appendChild(confirmBtn);
      container.appendChild(cancelBtn);

      // Position relative to the selection box - attach directly to the box
      box.appendChild(container);
      confirmButtonsContainer = container;
    }

    // Hide confirmation buttons
    function hideConfirmButtons() {
      if (confirmButtonsContainer && confirmButtonsContainer.parentNode) {
        confirmButtonsContainer.parentNode.removeChild(confirmButtonsContainer);
      }
      confirmButtonsContainer = null;
    }

    // Cancel selection editing - restore original region
    function cancelSelectionEdit() {
      console.log("cancelSelectionEdit called", {
        hasOriginalRegion: !!originalRegion,
        hasSelectionBox: !!currentSelectionBox,
        activeFieldIndex,
        isProcessing
      });

      if (!originalRegion || !currentSelectionBox || activeFieldIndex === null || isProcessing) {
        console.log("cancelSelectionEdit: early return");
        return;
      }

      const field = fields[activeFieldIndex];
      const pageDiv = currentPageDiv;
      const canvas = currentPageCanvas;

      if (!pageDiv || !canvas) {
        console.log("cancelSelectionEdit: no pageDiv or canvas");
        return;
      }

      // Restore original coordinates
      const r = originalRegion;
      const left = r.x1 * canvas.width;
      const top = r.y1 * canvas.height;
      const width = (r.x2 - r.x1) * canvas.width;
      const height = (r.y2 - r.y1) * canvas.height;

      console.log("cancelSelectionEdit: restoring", { left, top, width, height, originalRegion: r });

      // Update box position and size
      currentSelectionBox.style.left = left + "px";
      currentSelectionBox.style.top = top + "px";
      currentSelectionBox.style.width = width + "px";
      currentSelectionBox.style.height = height + "px";

      // Restore field region - update the correct occurrence
      const restoredRegion = {
        page: r.page,
        x1: r.x1,
        y1: r.y1,
        x2: r.x2,
        y2: r.y2
      };
      
      // Find and update the correct occurrence
      if (field._occurrences && field._occurrences.length > 0) {
        const occurrenceToRestore = field._occurrences.find(occ => 
          occ.region && occ.region.page === r.page
        );
        if (occurrenceToRestore) {
          occurrenceToRestore.region = restoredRegion;
          console.log("cancelSelectionEdit: restored occurrence for page", r.page);
        } else {
          // If no occurrence found, update field.region (backward compatibility)
          field.region = restoredRegion;
        }
      } else {
        // Backward compatibility - update field.region directly
        field.region = restoredRegion;
      }

      // Update overlays and hide buttons
      updateOverlays(pageDiv, currentSelectionBox);
      hideConfirmButtons();

      // Force re-render to update display
      renderFields();

      console.log("cancelSelectionEdit: completed, region restored");
      // Keep originalRegion for potential future cancels
    }

    function attachBoxInteractions(box) {
      const fieldIndex = Number(box.dataset.fieldIndex);
      const pageIndex = Number(box.dataset.pageIndex);
      const handles = {
        "resize-nw": box.querySelector(".resize-nw"),
        "resize-ne": box.querySelector(".resize-ne"),
        "resize-sw": box.querySelector(".resize-sw"),
        "resize-se": box.querySelector(".resize-se"),
      };

      box.addEventListener("click", (e) => {
        if (isDragging) return;
        e.stopPropagation();
        startSelectionForField(fieldIndex);
      });

      // Add hover effects to link box with field row
      box.addEventListener("mouseenter", () => {
        if (!selectionMode || !isDragging) {
          box.classList.add("hover-highlight");
          // Highlight corresponding field row
          const fieldRow = document.querySelector(`tr.field-row[data-field-index="${fieldIndex}"]`);
          if (fieldRow) {
            fieldRow.classList.add("hover-highlight");
          }
        }
      });

      box.addEventListener("mouseleave", () => {
        box.classList.remove("hover-highlight");
        // Remove highlight from field row
        const fieldRow = document.querySelector(`tr.field-row[data-field-index="${fieldIndex}"]`);
        if (fieldRow) {
          fieldRow.classList.remove("hover-highlight");
        }
      });

      box.addEventListener("mousedown", (e) => {
        if (!selectionMode || isProcessing) return;
        if (Object.values(handles).includes(e.target)) return;
        
        // Always ensure the field is active when clicking on its bbox
        if (activeFieldIndex !== fieldIndex) {
          activeFieldIndex = fieldIndex;
          const field = fields[fieldIndex];
          // Find the occurrence for this page
          let regionToUse = null;
          if (field._occurrences && field._occurrences.length > 0) {
            const occurrence = field._occurrences.find(occ => 
              occ.region && occ.region.page === pageIndex
            );
            if (occurrence && occurrence.region) {
              regionToUse = occurrence.region;
            }
          } else if (field.region && field.region.page === pageIndex) {
            regionToUse = field.region;
          }
          
          if (regionToUse) {
            editMode = true;
            createMode = false;
          }
          renderFields();
        }
        
        if (!editMode) return;
        e.stopPropagation();
        isDragging = true;
        dragType = "move";
        const rect = box.getBoundingClientRect();
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        startLeft = parseFloat(box.style.left);
        startTop = parseFloat(box.style.top);
        startWidth = rect.width;
        startHeight = rect.height;
        currentSelectionBox = box;
        currentPageDiv = box.parentElement;
        currentPageCanvas = currentPageDiv.querySelector("canvas");
        currentPageIndex = pageIndex;
        clearAllOverlays();
        hideConfirmButtons(); // Hide buttons when starting to drag
        updateOverlays(currentPageDiv, currentSelectionBox);
      });

      Object.entries(handles).forEach(([type, handle]) => {
        if (!handle) return;
        handle.addEventListener("mousedown", (e) => {
          if (!selectionMode || isProcessing) return;
          
          // Always ensure the field is active when clicking on its bbox handle
          if (activeFieldIndex !== fieldIndex) {
            activeFieldIndex = fieldIndex;
            const field = fields[fieldIndex];
            // Find the occurrence for this page
            let regionToUse = null;
            if (field._occurrences && field._occurrences.length > 0) {
              const occurrence = field._occurrences.find(occ => 
                occ.region && occ.region.page === pageIndex
              );
              if (occurrence && occurrence.region) {
                regionToUse = occurrence.region;
              }
            } else if (field.region && field.region.page === pageIndex) {
              regionToUse = field.region;
            }
            
            if (regionToUse) {
              editMode = true;
              createMode = false;
            }
            renderFields();
          }
          
          if (!editMode) return;
          e.stopPropagation();
          isDragging = true;
          dragType = type;
          const rect = box.getBoundingClientRect();
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          startLeft = parseFloat(box.style.left);
          startTop = parseFloat(box.style.top);
          startWidth = rect.width;
          startHeight = rect.height;
          currentSelectionBox = box;
          currentPageDiv = box.parentElement;
          currentPageCanvas = currentPageDiv.querySelector("canvas");
          currentPageIndex = pageIndex;
          clearAllOverlays();
          hideConfirmButtons(); // Hide buttons when starting to resize
          updateOverlays(currentPageDiv, currentSelectionBox);
        });
      });
    }

    function clearAllOverlays() {
      document.querySelectorAll(".dim-overlay").forEach((o) => o.remove());
    }

    function updateOverlays(pageDiv, box) {
      if (!pageDiv || !box) return;
      const pageWidth = pageDiv.clientWidth;
      const pageHeight = pageDiv.clientHeight;
      const left = parseFloat(box.style.left) || 0;
      const top = parseFloat(box.style.top) || 0;
      const width = parseFloat(box.style.width) || 0;
      const height = parseFloat(box.style.height) || 0;
      if (width <= 0 || height <= 0) return;

      let overlays = pageDiv.querySelectorAll(".dim-overlay");
      if (overlays.length < 4) {
        const need = 4 - overlays.length;
        for (let i = 0; i < need; i++) {
          const ov = document.createElement("div");
          ov.className = "dim-overlay";
          pageDiv.appendChild(ov);
        }
        overlays = pageDiv.querySelectorAll(".dim-overlay");
      }

      const [topOv, leftOv, rightOv, bottomOv] = overlays;
      topOv.style.left = "0px";
      topOv.style.top = "0px";
      topOv.style.width = pageWidth + "px";
      topOv.style.height = Math.max(0, top) + "px";
      leftOv.style.left = "0px";
      leftOv.style.top = top + "px";
      leftOv.style.width = Math.max(0, left) + "px";
      leftOv.style.height = Math.max(0, height) + "px";
      const rightWidth = Math.max(0, pageWidth - (left + width));
      rightOv.style.left = (left + width) + "px";
      rightOv.style.top = top + "px";
      rightOv.style.width = rightWidth + "px";
      rightOv.style.height = Math.max(0, height) + "px";
      const bottomHeight = Math.max(0, pageHeight - (top + height));
      bottomOv.style.left = "0px";
      bottomOv.style.top = (top + height) + "px";
      bottomOv.style.width = pageWidth + "px";
      bottomOv.style.height = bottomHeight + "px";
    }

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" || e.key === "Esc") {
        if (selectionMode || activeFieldIndex !== null) {
          e.preventDefault();
          activeFieldIndex = null;
          resetSelectionState(false);
          renderFields();
        }
      }
    });

    // Initialize
    if (documentId) {
      loadDocument();
    }
  </script>
</body>

</html>